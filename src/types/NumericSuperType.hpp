/*
   This file copyright (c) 2011-2013, the Quickstep authors.
   See file CREDITS.txt for details.
  
   This file is part of Quickstep.

   Quickstep is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
  
   Quickstep is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Quickstep.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef QUICKSTEP_TYPES_NUMERIC_SUPER_TYPE_HPP_
#define QUICKSTEP_TYPES_NUMERIC_SUPER_TYPE_HPP_

#include "types/Type.hpp"
#include "types/TypeErrors.hpp"
#include "types/TypeInstance.hpp"
#include "types/TypesConfig.h"
#include "utility/CstdintCompat.hpp"

// Disable type-conversion warnings generated by Visual Studio.
#ifdef QUICKSTEP_COMPILER_MSVC
#pragma warning(push)
#pragma warning(disable: 4244)
#endif

namespace quickstep {

/** \addtogroup Types
 *  @{
 */

/**
 * @brief Templatized superclass for Numeric types. Contains code common to all
 *        Numeric types.
 **/
template <typename CppType, class ReferenceTypeInstanceT, class LiteralTypeInstanceT>
class NumericSuperType : public Type {
 public:
  typedef CppType cpptype;

  SuperTypeID getSuperTypeID() const {
    return kNumeric;
  }

  bool isVariableLength() const {
    return false;
  }

  std::size_t minimumByteLength() const {
    return sizeof(CppType);
  }

  std::size_t maximumByteLength() const {
    return sizeof(CppType);
  }

  std::size_t estimateAverageByteLength() const {
    return sizeof(CppType);
  }

  std::size_t determineByteLength(const void *data) const {
    DEBUG_ASSERT(nullable_ || (data != NULL));
    if (data == NULL) {
      return 0;
    } else {
      return sizeof(CppType);
    }
  }

  bool isCoercibleTo(const Type &other) const {
    if (nullable_ && !other.isNullable()) {
      return false;
    }
    if (other.getSuperTypeID() == kNumeric) {
      return true;
    } else {
      return false;
    }
  }

  ReferenceTypeInstance* makeReferenceTypeInstance(const void *data) const {
    return new ReferenceTypeInstanceT(*this, data);
  }

  /**
   * @brief Create a LiteralTypeInstance of this Type.
   *
   * @param value The literal value.
   * @return A LiteralTypeInstance with the specified value.
   **/
  LiteralTypeInstance* makeLiteralTypeInstance(const CppType value) const {
    return new LiteralTypeInstanceT(*this, value);
  }

 protected:
  explicit NumericSuperType(const bool nullable)
      : Type(nullable) {
  }

 private:
  DISALLOW_COPY_AND_ASSIGN(NumericSuperType);
};

/**
 * @brief A templated reference of a NumericType.
 **/
template <typename CppType, class LiteralTypeInstanceT>
class NumericReferenceTypeInstance : public ReferenceTypeInstance {
 public:
  LiteralTypeInstance* makeCopy() const {
    if (isNull()) {
      return new NullLiteralTypeInstance(getType());
    } else {
      return new LiteralTypeInstanceT(getType(), *static_cast<const CppType*>(data_));
    }
  }

  bool supportsNumericInterface() const {
    return true;
  }

  inline int numericGetIntValue() const {
    return *(static_cast<const CppType*>(data_));
  }

  inline std::int64_t numericGetLongValue() const {
    return *(static_cast<const CppType*>(data_));
  }

  inline float numericGetFloatValue() const {
    return *(static_cast<const CppType*>(data_));
  }

  inline double numericGetDoubleValue() const {
    return *(static_cast<const CppType*>(data_));
  }

 protected:
  NumericReferenceTypeInstance(const Type &type, const void *data)
      : ReferenceTypeInstance(type, data) {
  }

  virtual void putToStreamUnsafe(std::ostream *stream) const {
    *stream << *(static_cast<const CppType*>(data_));
  }

 private:
  DISALLOW_COPY_AND_ASSIGN(NumericReferenceTypeInstance);
};

/**
 * @brief A templated literal of a NumericType.
 **/
template <typename CppType>
class NumericLiteralTypeInstance : public LiteralTypeInstance {
 public:
  ~NumericLiteralTypeInstance() {
  }

  const void* getDataPtr() const {
    return &value_;
  }

  LiteralTypeInstance* makeCopy() const {
    return new NumericLiteralTypeInstance(getType(), value_);
  }

  bool supportsNumericInterface() const {
    return true;
  }

  inline int numericGetIntValue() const {
    return value_;
  }

  inline std::int64_t numericGetLongValue() const {
    return value_;
  }

  inline float numericGetFloatValue() const {
    return value_;
  }

  inline double numericGetDoubleValue() const {
    return value_;
  }

 protected:
  virtual void putToStreamUnsafe(std::ostream *stream) const {
    *stream << value_;
  }

  NumericLiteralTypeInstance(const Type &type, const CppType value)
      : LiteralTypeInstance(type), value_(value) {
  }

  const CppType value_;

 private:
  DISALLOW_COPY_AND_ASSIGN(NumericLiteralTypeInstance);
};

/** @} */

}  // namespace quickstep

// Restore original warning state for Visual Studio.
#ifdef QUICKSTEP_COMPILER_MSVC
#pragma warning(pop)
#endif

#endif  // QUICKSTEP_TYPES_NUMERIC_SUPER_TYPE_HPP_
